// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
#include <bpkg/types-parsers.hxx>
//
// End prologue.

#include <bpkg/common-options.hxx>

#include <map>
#include <set>
#include <string>
#include <vector>
#include <ostream>
#include <sstream>
#include <cstring>
#include <fstream>

namespace bpkg
{
  namespace cli
  {
    // unknown_option
    //
    unknown_option::
    ~unknown_option () throw ()
    {
    }

    void unknown_option::
    print (::std::ostream& os) const
    {
      os << "unknown option '" << option ().c_str () << "'";
    }

    const char* unknown_option::
    what () const throw ()
    {
      return "unknown option";
    }

    // unknown_argument
    //
    unknown_argument::
    ~unknown_argument () throw ()
    {
    }

    void unknown_argument::
    print (::std::ostream& os) const
    {
      os << "unknown argument '" << argument ().c_str () << "'";
    }

    const char* unknown_argument::
    what () const throw ()
    {
      return "unknown argument";
    }

    // missing_value
    //
    missing_value::
    ~missing_value () throw ()
    {
    }

    void missing_value::
    print (::std::ostream& os) const
    {
      os << "missing value for option '" << option ().c_str () << "'";
    }

    const char* missing_value::
    what () const throw ()
    {
      return "missing option value";
    }

    // invalid_value
    //
    invalid_value::
    ~invalid_value () throw ()
    {
    }

    void invalid_value::
    print (::std::ostream& os) const
    {
      os << "invalid value '" << value ().c_str () << "' for option '"
         << option ().c_str () << "'";

      if (!message ().empty ())
        os << ": " << message ().c_str ();
    }

    const char* invalid_value::
    what () const throw ()
    {
      return "invalid option value";
    }

    // eos_reached
    //
    void eos_reached::
    print (::std::ostream& os) const
    {
      os << what ();
    }

    const char* eos_reached::
    what () const throw ()
    {
      return "end of argument stream reached";
    }

    // file_io_failure
    //
    file_io_failure::
    ~file_io_failure () throw ()
    {
    }

    void file_io_failure::
    print (::std::ostream& os) const
    {
      os << "unable to open file '" << file ().c_str () << "' or read failure";
    }

    const char* file_io_failure::
    what () const throw ()
    {
      return "unable to open file or read failure";
    }

    // unmatched_quote
    //
    unmatched_quote::
    ~unmatched_quote () throw ()
    {
    }

    void unmatched_quote::
    print (::std::ostream& os) const
    {
      os << "unmatched quote in argument '" << argument ().c_str () << "'";
    }

    const char* unmatched_quote::
    what () const throw ()
    {
      return "unmatched quote";
    }

    // unexpected_group
    //
    unexpected_group::
    ~unexpected_group () throw ()
    {
    }

    void unexpected_group::
    print (::std::ostream& os) const
    {
      os << "unexpected grouped argument '" << group_ << "' "
         << "for argument '" << argument_ << "'";
    }

    const char* unexpected_group::
    what () const throw ()
    {
      return "unexpected grouped argument";
    }

    // group_separator
    //
    group_separator::
    ~group_separator () throw ()
    {
    }

    void group_separator::
    print (::std::ostream& os) const
    {
      bool ex (!expected_.empty ());
      bool en (!encountered_.empty ());

      if (ex)
      {
        os << "expected group separator '" << expected_ << "'";
        if (en)
          os << " instead of '" << encountered_ << "'";
      }
      else
        os << "unexpected group separator '" << encountered_ << "'";

      if (en)
        os << ", use '\\" << encountered_ << "' to escape";
    }

    const char* group_separator::
    what () const throw ()
    {
      bool ex (!expected_.empty ());
      bool en (!encountered_.empty ());

      return en
        ? ex ? "wrong group separator"    : "unexpected group separator"
        : ex ? "expected group separator" : "";
    }

    // scanner
    //
    scanner::
    ~scanner ()
    {
    }

    // argv_scanner
    //
    bool argv_scanner::
    more ()
    {
      return i_ < argc_;
    }

    const char* argv_scanner::
    peek ()
    {
      if (i_ < argc_)
        return argv_[i_];
      else
        throw eos_reached ();
    }

    const char* argv_scanner::
    next ()
    {
      if (i_ < argc_)
      {
        const char* r (argv_[i_]);

        if (erase_)
        {
          for (int i (i_ + 1); i < argc_; ++i)
            argv_[i - 1] = argv_[i];

          --argc_;
          argv_[argc_] = 0;
        }
        else
          ++i_;

        return r;
      }
      else
        throw eos_reached ();
    }

    void argv_scanner::
    skip ()
    {
      if (i_ < argc_)
        ++i_;
      else
        throw eos_reached ();
    }

    // vector_scanner
    //
    bool vector_scanner::
    more ()
    {
      return i_ < v_.size ();
    }

    const char* vector_scanner::
    peek ()
    {
      if (i_ < v_.size ())
        return v_[i_].c_str ();
      else
        throw eos_reached ();
    }

    const char* vector_scanner::
    next ()
    {
      if (i_ < v_.size ())
        return v_[i_++].c_str ();
      else
        throw eos_reached ();
    }

    void vector_scanner::
    skip ()
    {
      if (i_ < v_.size ())
        ++i_;
      else
        throw eos_reached ();
    }

    // argv_file_scanner
    //
    int argv_file_scanner::zero_argc_ = 0;
    std::string argv_file_scanner::empty_string_;

    bool argv_file_scanner::
    more ()
    {
      if (!args_.empty ())
        return true;

      while (base::more ())
      {
        // See if the next argument is the file option.
        //
        const char* a (base::peek ());
        const option_info* oi = 0;
        const char* ov = 0;

        if (!skip_)
        {
          if ((oi = find (a)) != 0)
          {
            base::next ();

            if (!base::more ())
              throw missing_value (a);

            ov = base::next ();
          }
          else if (std::strncmp (a, "-", 1) == 0)
          {
            if ((ov = std::strchr (a, '=')) != 0)
            {
              std::string o (a, 0, ov - a);
              if ((oi = find (o.c_str ())) != 0)
              {
                base::next ();
                ++ov;
              }
            }
          }
        }

        if (oi != 0)
        {
          if (oi->search_func != 0)
          {
            std::string f (oi->search_func (ov, oi->arg));

            if (!f.empty ())
              load (f);
          }
          else
            load (ov);

          if (!args_.empty ())
            return true;
        }
        else
        {
          if (!skip_)
            skip_ = (std::strcmp (a, "--") == 0);

          return true;
        }
      }

      return false;
    }

    const char* argv_file_scanner::
    peek ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? base::peek () : args_.front ().value.c_str ();
    }

    const std::string& argv_file_scanner::
    peek_file ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? empty_string_ : *args_.front ().file;
    }

    std::size_t argv_file_scanner::
    peek_line ()
    {
      if (!more ())
        throw eos_reached ();

      return args_.empty () ? 0 : args_.front ().line;
    }

    const char* argv_file_scanner::
    next ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::next ();
      else
      {
        hold_[i_ == 0 ? ++i_ : --i_].swap (args_.front ().value);
        args_.pop_front ();
        return hold_[i_].c_str ();
      }
    }

    void argv_file_scanner::
    skip ()
    {
      if (!more ())
        throw eos_reached ();

      if (args_.empty ())
        return base::skip ();
      else
        args_.pop_front ();
    }

    const argv_file_scanner::option_info* argv_file_scanner::
    find (const char* a) const
    {
      for (std::size_t i (0); i < options_count_; ++i)
        if (std::strcmp (a, options_[i].option) == 0)
          return &options_[i];

      return 0;
    }

    void argv_file_scanner::
    load (const std::string& file)
    {
      using namespace std;

      ifstream is (file.c_str ());

      if (!is.is_open ())
        throw file_io_failure (file);

      files_.push_back (file);

      arg a;
      a.file = &*files_.rbegin ();

      for (a.line = 1; !is.eof (); ++a.line)
      {
        string line;
        getline (is, line);

        if (is.fail () && !is.eof ())
          throw file_io_failure (file);

        string::size_type n (line.size ());

        // Trim the line from leading and trailing whitespaces.
        //
        if (n != 0)
        {
          const char* f (line.c_str ());
          const char* l (f + n);

          const char* of (f);
          while (f < l && (*f == ' ' || *f == '\t' || *f == '\r'))
            ++f;

          --l;

          const char* ol (l);
          while (l > f && (*l == ' ' || *l == '\t' || *l == '\r'))
            --l;

          if (f != of || l != ol)
            line = f <= l ? string (f, l - f + 1) : string ();
        }

        // Ignore empty lines, those that start with #.
        //
        if (line.empty () || line[0] == '#')
          continue;

        string::size_type p (string::npos);
        if (line.compare (0, 1, "-") == 0)
        {
          p = line.find (' ');

          string::size_type q (line.find ('='));
          if (q != string::npos && q < p)
            p = q;
        }

        string s1;
        if (p != string::npos)
        {
          s1.assign (line, 0, p);

          // Skip leading whitespaces in the argument.
          //
          if (line[p] == '=')
            ++p;
          else
          {
            n = line.size ();
            for (++p; p < n; ++p)
            {
              char c (line[p]);
              if (c != ' ' && c != '\t' && c != '\r')
                break;
            }
          }
        }
        else if (!skip_)
          skip_ = (line == "--");

        string s2 (line, p != string::npos ? p : 0);

        // If the string (which is an option value or argument) is
        // wrapped in quotes, remove them.
        //
        n = s2.size ();
        char cf (s2[0]), cl (s2[n - 1]);

        if (cf == '"' || cf == '\'' || cl == '"' || cl == '\'')
        {
          if (n == 1 || cf != cl)
            throw unmatched_quote (s2);

          s2 = string (s2, 1, n - 2);
        }

        if (!s1.empty ())
        {
          // See if this is another file option.
          //
          const option_info* oi;
          if (!skip_ && (oi = find (s1.c_str ())))
          {
            if (s2.empty ())
              throw missing_value (oi->option);

            if (oi->search_func != 0)
            {
              std::string f (oi->search_func (s2.c_str (), oi->arg));
              if (!f.empty ())
                load (f);
            }
            else
              load (s2);

            continue;
          }

          a.value = s1;
          args_.push_back (a);
        }

        a.value = s2;
        args_.push_back (a);
      }
    }

    // group_scanner
    //
    bool group_scanner::
    more ()
    {
      // We don't want to call scan_group() here since that
      // would invalidate references to previous arguments.
      // But we do need to check that the previous group was
      // handled.
      //
      if (state_ == scanned)
      {
        if (group_scan_.end () != group_.size ())
          throw unexpected_group (arg_[i_], group_scan_.next ());
      }

      return scan_.more ();
    }

    const char* group_scanner::
    peek ()
    {
      if (state_ != peeked)
        scan_group (peeked);
      scan_.peek ();
      // Return unescaped.
      return arg_[i_].c_str ();
    }

    const char* group_scanner::
    next ()
    {
      if (state_ != peeked)
        scan_group (peeked);
      scan_.next ();
      scan_group (scanned);
      // Return unescaped.
      return arg_[i_].c_str ();
    }

    void group_scanner::
    skip ()
    {
      if (state_ != peeked)
        scan_group (peeked);
      scan_.skip ();
      scan_group (skipped);
    }

    void group_scanner::
    scan_group (state st)
    {
      // If the previous argument has been scanned, then make
      // sure the group has been scanned (handled) as well.
      //
      if (state_ == scanned)
      {
        if (group_scan_.end () != group_.size ())
          throw unexpected_group (arg_[i_], group_scan_.next ());
      }

      if (state_ != peeked)
      {
        arg_[i_ == 0 ? ++i_ : --i_].clear ();
        group_.clear ();
        group_scan_.reset ();
      }

      // We recognize all group sequences both before and 
      // after the argument and diagnose any misuse. We may
      // also have multiple groups:
      //
      // { -x }+ { -y }+ arg
      //

      // Using group_ won't cover empty groups.
      //
      bool g (false);

      while (scan_.more ())
      {
        const char* a (scan_.peek ());
        size_t i (*a == '\\' ? 1 : 0);
        separator s (sense (a + i));

        if (s == none || i != 0)
        {
          if (state_ != peeked)
            arg_[i_] = a + (s != none ? i : 0);
          break;
        }

        // Start of a leading group for the next argument.
        //
        if (s == open && state_ == peeked)
          break;

        if (s != (state_ == peeked ? open_plus : open))
          throw group_separator (a, "");

        g = true;

        // Scan the group until the closing separator.
        //
        scan_.next ();
        s = none;
        while (s == none && scan_.more ())
        {
          a = scan_.next ();
          i = (*a == '\\' ? 1 : 0);
          s = sense (a + i);

          if (s == none || i != 0)
          {
            group_.push_back (a + (s != none ? i : 0));
            s = none;
          }
        }

        if (s != (state_ == peeked ? close : close_plus))
        {
          throw group_separator ((s != none        ? a   : ""),
                                 (state_ == peeked ? "}" : "}+"));
        }
      }

      // Handle the case where we have seen the leading group
      // but there are no more arguments.
      //
      if (g && state_ != peeked && !scan_.more ())
        throw group_separator ("{", "");

      state_ = st;
    }

    template <typename X>
    struct parser
    {
      static void
      parse (X& x, bool& xs, scanner& s)
      {
        using namespace std;

        const char* o (s.next ());
        if (s.more ())
        {
          string v (s.next ());
          istringstream is (v);
          if (!(is >> x && is.peek () == istringstream::traits_type::eof ()))
            throw invalid_value (o, v);
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (X& b, const X& a)
      {
        b = a;
      }
    };

    template <>
    struct parser<bool>
    {
      static void
      parse (bool& x, scanner& s)
      {
        s.next ();
        x = true;
      }

      static void
      merge (bool& b, const bool&)
      {
        b = true;
      }
    };

    template <>
    struct parser<std::string>
    {
      static void
      parse (std::string& x, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
          x = s.next ();
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (std::string& b, const std::string& a)
      {
        b = a;
      }
    };

    template <typename X>
    struct parser<std::vector<X> >
    {
      static void
      parse (std::vector<X>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.push_back (x);
        xs = true;
      }

      static void
      merge (std::vector<X>& b, const std::vector<X>& a)
      {
        b.insert (b.end (), a.begin (), a.end ());
      }
    };

    template <typename X>
    struct parser<std::set<X> >
    {
      static void
      parse (std::set<X>& c, bool& xs, scanner& s)
      {
        X x;
        bool dummy;
        parser<X>::parse (x, dummy, s);
        c.insert (x);
        xs = true;
      }

      static void
      merge (std::set<X>& b, const std::set<X>& a)
      {
        b.insert (a.begin (), a.end ());
      }
    };

    template <typename K, typename V>
    struct parser<std::map<K, V> >
    {
      static void
      parse (std::map<K, V>& m, bool& xs, scanner& s)
      {
        const char* o (s.next ());

        if (s.more ())
        {
          std::string ov (s.next ());
          std::string::size_type p = ov.find ('=');

          K k = K ();
          V v = V ();
          std::string kstr (ov, 0, p);
          std::string vstr (ov, (p != std::string::npos ? p + 1 : ov.size ()));

          int ac (2);
          char* av[] =
          {
            const_cast<char*> (o),
            0
          };

          bool dummy;
          if (!kstr.empty ())
          {
            av[1] = const_cast<char*> (kstr.c_str ());
            argv_scanner s (0, ac, av);
            parser<K>::parse (k, dummy, s);
          }

          if (!vstr.empty ())
          {
            av[1] = const_cast<char*> (vstr.c_str ());
            argv_scanner s (0, ac, av);
            parser<V>::parse (v, dummy, s);
          }

          m[k] = v;
        }
        else
          throw missing_value (o);

        xs = true;
      }

      static void
      merge (std::map<K, V>& b, const std::map<K, V>& a)
      {
        for (typename std::map<K, V>::const_iterator i (a.begin ()); 
             i != a.end (); 
             ++i)
          b[i->first] = i->second;
      }
    };

    template <typename X, typename T, T X::*M>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, s);
    }

    template <typename X, typename T, T X::*M, bool X::*S>
    void
    thunk (X& x, scanner& s)
    {
      parser<T>::parse (x.*M, x.*S, s);
    }
  }
}

#include <map>
#include <cstring>

namespace bpkg
{
  // common_options
  //

  common_options::
  common_options ()
  : v_ (),
    V_ (),
    quiet_ (),
    verbose_ (1),
    verbose_specified_ (false),
    jobs_ (),
    jobs_specified_ (false),
    no_result_ (),
    no_progress_ (),
    build_ (),
    build_specified_ (false),
    build_option_ (),
    build_option_specified_ (false),
    fetch_ (),
    fetch_specified_ (false),
    fetch_option_ (),
    fetch_option_specified_ (false),
    fetch_timeout_ (),
    fetch_timeout_specified_ (false),
    pkg_proxy_ (),
    pkg_proxy_specified_ (false),
    git_ ("git"),
    git_specified_ (false),
    git_option_ (),
    git_option_specified_ (false),
    sha256_ (),
    sha256_specified_ (false),
    sha256_option_ (),
    sha256_option_specified_ (false),
    tar_ (),
    tar_specified_ (false),
    tar_option_ (),
    tar_option_specified_ (false),
    openssl_ ("openssl"),
    openssl_specified_ (false),
    openssl_option_ (),
    openssl_option_specified_ (false),
    auth_ (bpkg::auth::remote),
    auth_specified_ (false),
    trust_ (),
    trust_specified_ (false),
    trust_yes_ (),
    trust_no_ (),
    pager_ (),
    pager_specified_ (false),
    pager_option_ (),
    pager_option_specified_ (false),
    options_file_ (),
    options_file_specified_ (false),
    default_options_ (),
    default_options_specified_ (false),
    no_default_options_ ()
  {
  }

  void common_options::
  merge (const common_options& a)
  {
    CLI_POTENTIALLY_UNUSED (a);

    if (a.v_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->v_, a.v_);
    }

    if (a.V_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->V_, a.V_);
    }

    if (a.quiet_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->quiet_, a.quiet_);
    }

    if (a.verbose_specified_)
    {
      ::bpkg::cli::parser< uint16_t>::merge (
        this->verbose_, a.verbose_);
      this->verbose_specified_ = true;
    }

    if (a.jobs_specified_)
    {
      ::bpkg::cli::parser< size_t>::merge (
        this->jobs_, a.jobs_);
      this->jobs_specified_ = true;
    }

    if (a.no_result_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_result_, a.no_result_);
    }

    if (a.no_progress_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_progress_, a.no_progress_);
    }

    if (a.build_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->build_, a.build_);
      this->build_specified_ = true;
    }

    if (a.build_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->build_option_, a.build_option_);
      this->build_option_specified_ = true;
    }

    if (a.fetch_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->fetch_, a.fetch_);
      this->fetch_specified_ = true;
    }

    if (a.fetch_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->fetch_option_, a.fetch_option_);
      this->fetch_option_specified_ = true;
    }

    if (a.fetch_timeout_specified_)
    {
      ::bpkg::cli::parser< size_t>::merge (
        this->fetch_timeout_, a.fetch_timeout_);
      this->fetch_timeout_specified_ = true;
    }

    if (a.pkg_proxy_specified_)
    {
      ::bpkg::cli::parser< butl::url>::merge (
        this->pkg_proxy_, a.pkg_proxy_);
      this->pkg_proxy_specified_ = true;
    }

    if (a.git_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->git_, a.git_);
      this->git_specified_ = true;
    }

    if (a.git_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->git_option_, a.git_option_);
      this->git_option_specified_ = true;
    }

    if (a.sha256_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->sha256_, a.sha256_);
      this->sha256_specified_ = true;
    }

    if (a.sha256_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->sha256_option_, a.sha256_option_);
      this->sha256_option_specified_ = true;
    }

    if (a.tar_specified_)
    {
      ::bpkg::cli::parser< path>::merge (
        this->tar_, a.tar_);
      this->tar_specified_ = true;
    }

    if (a.tar_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->tar_option_, a.tar_option_);
      this->tar_option_specified_ = true;
    }

    if (a.openssl_specified_)
    {
      ::bpkg::cli::parser< qualified_option<openssl_commands, path>>::merge (
        this->openssl_, a.openssl_);
      this->openssl_specified_ = true;
    }

    if (a.openssl_option_specified_)
    {
      ::bpkg::cli::parser< qualified_option<openssl_commands, strings>>::merge (
        this->openssl_option_, a.openssl_option_);
      this->openssl_option_specified_ = true;
    }

    if (a.auth_specified_)
    {
      ::bpkg::cli::parser< bpkg::auth>::merge (
        this->auth_, a.auth_);
      this->auth_specified_ = true;
    }

    if (a.trust_specified_)
    {
      ::bpkg::cli::parser< std::set<string>>::merge (
        this->trust_, a.trust_);
      this->trust_specified_ = true;
    }

    if (a.trust_yes_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->trust_yes_, a.trust_yes_);
    }

    if (a.trust_no_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->trust_no_, a.trust_no_);
    }

    if (a.pager_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->pager_, a.pager_);
      this->pager_specified_ = true;
    }

    if (a.pager_option_specified_)
    {
      ::bpkg::cli::parser< strings>::merge (
        this->pager_option_, a.pager_option_);
      this->pager_option_specified_ = true;
    }

    if (a.options_file_specified_)
    {
      ::bpkg::cli::parser< string>::merge (
        this->options_file_, a.options_file_);
      this->options_file_specified_ = true;
    }

    if (a.default_options_specified_)
    {
      ::bpkg::cli::parser< dir_path>::merge (
        this->default_options_, a.default_options_);
      this->default_options_specified_ = true;
    }

    if (a.no_default_options_)
    {
      ::bpkg::cli::parser< bool>::merge (
        this->no_default_options_, a.no_default_options_);
    }
  }

  ::bpkg::cli::usage_para common_options::
  print_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mCOMMON OPTIONS\033[0m" << ::std::endl;

    os << std::endl
       << "The common options are summarized below with a more detailed description" << ::std::endl
       << "available in \033[1mbpkg-common-options(1)\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m-v\033[0m                       Print essential underlying commands being executed." << ::std::endl;

    os << "\033[1m-V\033[0m                       Print all underlying commands being executed." << ::std::endl;

    os << "\033[1m--quiet\033[0m|\033[1m-q\033[0m               Run quietly, only printing error messages." << ::std::endl;

    os << "\033[1m--verbose\033[0m \033[4mlevel\033[0m          Set the diagnostics verbosity to \033[4mlevel\033[0m between 0 and" << ::std::endl
       << "                         6." << ::std::endl;

    os << "\033[1m--jobs\033[0m|\033[1m-j\033[0m \033[4mnum\033[0m            Number of jobs to perform in parallel." << ::std::endl;

    os << "\033[1m--no-result\033[0m              Don't print informational messages about the outcome" << ::std::endl
       << "                         of performing a command." << ::std::endl;

    os << "\033[1m--no-progress\033[0m            Suppress progress indicators for long-lasting" << ::std::endl
       << "                         operations, such as network transfers, building, etc." << ::std::endl;

    os << "\033[1m--build\033[0m \033[4mpath\033[0m             The build program to be used to build packages." << ::std::endl;

    os << "\033[1m--build-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the build program." << ::std::endl;

    os << "\033[1m--fetch\033[0m \033[4mpath\033[0m             The fetch program to be used to download resources." << ::std::endl;

    os << "\033[1m--fetch-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the fetch program." << ::std::endl;

    os << "\033[1m--fetch-timeout\033[0m \033[4msec\033[0m      The fetch and fetch-like (for example, \033[1mgit\033[0m) program" << ::std::endl
       << "                         timeout." << ::std::endl;

    os << "\033[1m--pkg-proxy\033[0m \033[4murl\033[0m          HTTP proxy server to use when fetching package" << ::std::endl
       << "                         manifests and archives from remote \033[1mpkg\033[0m repositories." << ::std::endl;

    os << "\033[1m--git\033[0m \033[4mpath\033[0m               The git program to be used to fetch git repositories." << ::std::endl;

    os << "\033[1m--git-option\033[0m \033[4mopt\033[0m         Additional common option to be passed to the git" << ::std::endl
       << "                         program." << ::std::endl;

    os << "\033[1m--sha256\033[0m \033[4mpath\033[0m            The sha256 program to be used to calculate SHA256" << ::std::endl
       << "                         sums." << ::std::endl;

    os << "\033[1m--sha256-option\033[0m \033[4mopt\033[0m      Additional option to be passed to the sha256 program." << ::std::endl;

    os << "\033[1m--tar\033[0m \033[4mpath\033[0m               The tar program to be used to extract package" << ::std::endl
       << "                         archives." << ::std::endl;

    os << "\033[1m--tar-option\033[0m \033[4mopt\033[0m         Additional option to be passed to the tar program." << ::std::endl;

    os << "\033[1m--openssl\033[0m \033[4mpath\033[0m           The openssl program to be used for crypto operations." << ::std::endl;

    os << "\033[1m--openssl-option\033[0m \033[4mopt\033[0m     Additional option to be passed to the openssl program." << ::std::endl;

    os << "\033[1m--auth\033[0m \033[4mtype\033[0m              Types of repositories to authenticate." << ::std::endl;

    os << "\033[1m--trust\033[0m \033[4mfingerprint\033[0m      Trust repository certificate with a SHA256" << ::std::endl
       << "                         \033[4mfingerprint\033[0m." << ::std::endl;

    os << "\033[1m--trust-yes\033[0m              Assume the answer to all authentication prompts is" << ::std::endl
       << "                         \033[1myes\033[0m." << ::std::endl;

    os << "\033[1m--trust-no\033[0m               Assume the answer to all authentication prompts is \033[1mno\033[0m." << ::std::endl;

    os << "\033[1m--pager\033[0m \033[4mpath\033[0m             The pager program to be used to show long text." << ::std::endl;

    os << "\033[1m--pager-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the pager program." << ::std::endl;

    os << "\033[1m--options-file\033[0m \033[4mfile\033[0m      Read additional options from \033[4mfile\033[0m." << ::std::endl;

    os << "\033[1m--default-options\033[0m \033[4mdir\033[0m    The directory to load additional default options files" << ::std::endl
       << "                         from." << ::std::endl;

    os << "\033[1m--no-default-options\033[0m     Don't load default options files." << ::std::endl;

    p = ::bpkg::cli::usage_para::option;

    return p;
  }

  ::bpkg::cli::usage_para common_options::
  print_long_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mCOMMON OPTIONS\033[0m" << ::std::endl;

    os << std::endl
       << "\033[1m-v\033[0m                       Print essential underlying commands being executed." << ::std::endl
       << "                         This is equivalent to \033[1m--verbose 2\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m-V\033[0m                       Print all underlying commands being executed. This is" << ::std::endl
       << "                         equivalent to \033[1m--verbose 3\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--quiet\033[0m|\033[1m-q\033[0m               Run quietly, only printing error messages. This is" << ::std::endl
       << "                         equivalent to \033[1m--verbose 0\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--verbose\033[0m \033[4mlevel\033[0m          Set the diagnostics verbosity to \033[4mlevel\033[0m between 0 and" << ::std::endl
       << "                         6. Level 0 disables any non-error messages while level" << ::std::endl
       << "                         6 produces lots of information, with level 1 being the" << ::std::endl
       << "                         default. The following additional types of diagnostics" << ::std::endl
       << "                         are produced at each level:" << ::std::endl
       << ::std::endl
       << "                         1. High-level information messages." << ::std::endl
       << "                         2. Essential underlying commands being executed." << ::std::endl
       << "                         3. All underlying commands being executed." << ::std::endl
       << "                         4. Information that could be helpful to the user." << ::std::endl
       << "                         5. Information that could be helpful to the developer." << ::std::endl
       << "                         6. Even more detailed information." << ::std::endl;

    os << std::endl
       << "\033[1m--jobs\033[0m|\033[1m-j\033[0m \033[4mnum\033[0m            Number of jobs to perform in parallel. If this option" << ::std::endl
       << "                         is not specified or specified with the 0\033[0m value, then" << ::std::endl
       << "                         the number of available hardware threads is used. This" << ::std::endl
       << "                         option is also propagated when performing build system" << ::std::endl
       << "                         operations such as \033[1mupdate\033[0m, \033[1mtest\033[0m, etc." << ::std::endl;

    os << std::endl
       << "\033[1m--no-result\033[0m              Don't print informational messages about the outcome" << ::std::endl
       << "                         of performing a command." << ::std::endl;

    os << std::endl
       << "\033[1m--no-progress\033[0m            Suppress progress indicators for long-lasting" << ::std::endl
       << "                         operations, such as network transfers, building, etc." << ::std::endl;

    os << std::endl
       << "\033[1m--build\033[0m \033[4mpath\033[0m             The build program to be used to build packages. This" << ::std::endl
       << "                         should be the path to the build2 \033[1mb\033[0m executable. You can" << ::std::endl
       << "                         also specify additional options that should be passed" << ::std::endl
       << "                         to the build program with \033[1m--build-option\033[0m." << ::std::endl
       << ::std::endl
       << "                         If the build program is not explicitly specified, then" << ::std::endl
       << "                         \033[1mbpkg\033[0m will by default use \033[1mb\033[0m plus an executable suffix" << ::std::endl
       << "                         if one was specified when building \033[1mbpkg\033[0m. So, for" << ::std::endl
       << "                         example, if \033[1mbpkg\033[0m name was set to \033[1mbpkg-1.0\033[0m, then it" << ::std::endl
       << "                         will look for \033[1mb-1.0\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--build-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the build program." << ::std::endl
       << "                         See \033[1m--build\033[0m for more information on the build program." << ::std::endl
       << "                         Repeat this option to specify multiple build options." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch\033[0m \033[4mpath\033[0m             The fetch program to be used to download resources." << ::std::endl
       << "                         Currently, \033[1mbpkg\033[0m recognizes \033[1mcurl\033[0m, \033[1mwget\033[0m, and \033[1mfetch\033[0m. Note" << ::std::endl
       << "                         that the last component of \033[4mpath\033[0m must contain one of" << ::std::endl
       << "                         these names as a substring in order for \033[1mbpkg\033[0m to" << ::std::endl
       << "                         recognize which program is being used. You can also" << ::std::endl
       << "                         specify additional options that should be passed to" << ::std::endl
       << "                         the fetch program with \033[1m--fetch-option\033[0m." << ::std::endl
       << ::std::endl
       << "                         If the fetch program is not specified, then \033[1mbpkg\033[0m will" << ::std::endl
       << "                         try to discover if one of the above programs is" << ::std::endl
       << "                         available and use that. Currently, \033[1mbpkg\033[0m has the" << ::std::endl
       << "                         following preference order: \033[1mwget\033[0m 1.16 or higher" << ::std::endl
       << "                         (supports \033[1m--show-progress\033[0m), \033[1mcurl\033[0m, \033[1mwget\033[0m, and \033[1mfetch\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the fetch program." << ::std::endl
       << "                         See \033[1m--fetch\033[0m for more information on the fetch program." << ::std::endl
       << "                         Repeat this option to specify multiple fetch options." << ::std::endl;

    os << std::endl
       << "\033[1m--fetch-timeout\033[0m \033[4msec\033[0m      The fetch and fetch-like (for example, \033[1mgit\033[0m) program" << ::std::endl
       << "                         timeout. While the exact semantics of the value" << ::std::endl
       << "                         depends on the program used, at a minimum it specifies" << ::std::endl
       << "                         in seconds the maximum time that can be spent without" << ::std::endl
       << "                         any network activity." << ::std::endl
       << ::std::endl
       << "                         Specifically, it is translated to the \033[1m--max-time\033[0m" << ::std::endl
       << "                         option for \033[1mcurl\033[0m and to the \033[1m--timeout\033[0m option for \033[1mwget\033[0m" << ::std::endl
       << "                         and \033[1mfetch\033[0m. For \033[1mgit\033[0m over HTTP/HTTPS this semantics is" << ::std::endl
       << "                         achieved using the \033[1mhttp.lowSpeedLimit\033[0m=\033[4m1\033[0m" << ::std::endl
       << "                         \033[1mhttp.lowSpeedTime\033[0m=\033[4msec\033[0m configuration values (the" << ::std::endl
       << "                         \033[1mgit://\033[0m and \033[1mssh://\033[0m protocols currently do not support" << ::std::endl
       << "                         timeouts)." << ::std::endl
       << ::std::endl
       << "                         See \033[1m--fetch\033[0m and \033[1m--git\033[0m for more information on the" << ::std::endl
       << "                         fetch programs." << ::std::endl;

    os << std::endl
       << "\033[1m--pkg-proxy\033[0m \033[4murl\033[0m          HTTP proxy server to use when fetching package" << ::std::endl
       << "                         manifests and archives from remote \033[1mpkg\033[0m repositories." << ::std::endl
       << "                         If specified, the proxy \033[4murl\033[0m must be in the" << ::std::endl
       << "                         \033[1mhttp://\033[0m\033[4mhost\033[0m[\033[1m:\033[0m\033[4mport\033[0m]\033[0m form. If \033[4mport\033[0m is omitted, 80 is" << ::std::endl
       << "                         used by default." << ::std::endl
       << ::std::endl
       << "                         Note that to allow caching, the proxied \033[1mhttps://\033[0m URLs" << ::std::endl
       << "                         are converted to \033[1mhttp://\033[0m in order to prevent the fetch" << ::std::endl
       << "                         program from tunneling (which is the standard approach" << ::std::endl
       << "                         for proxying HTTPS). If both HTTP and HTTPS" << ::std::endl
       << "                         repositories are used, it is assumed that the proxy" << ::std::endl
       << "                         server can figure out which URLs need to be converted" << ::std::endl
       << "                         back to \033[1mhttps://\033[0m based on the request information (for" << ::std::endl
       << "                         example, host name). For security, this mechanism" << ::std::endl
       << "                         should only be used with signed repositories or when" << ::std::endl
       << "                         the proxy is located inside a trusted network." << ::std::endl;

    os << std::endl
       << "\033[1m--git\033[0m \033[4mpath\033[0m               The git program to be used to fetch git repositories." << ::std::endl
       << "                         You can also specify additional options that should be" << ::std::endl
       << "                         passed to the git program with \033[1m--git-option\033[0m." << ::std::endl
       << ::std::endl
       << "                         If the git program is not explicitly specified, then" << ::std::endl
       << "                         \033[1mbpkg\033[0m will use \033[1mgit\033[0m by default." << ::std::endl;

    os << std::endl
       << "\033[1m--git-option\033[0m \033[4mopt\033[0m         Additional common option to be passed to the git" << ::std::endl
       << "                         program. Note that the common options are the ones" << ::std::endl
       << "                         that precede the \033[1mgit\033[0m command. See \033[1m--git\033[0m for more" << ::std::endl
       << "                         information on the git program. Repeat this option to" << ::std::endl
       << "                         specify multiple git options." << ::std::endl;

    os << std::endl
       << "\033[1m--sha256\033[0m \033[4mpath\033[0m            The sha256 program to be used to calculate SHA256" << ::std::endl
       << "                         sums. Currently, \033[1mbpkg\033[0m recognizes \033[1msha256\033[0m, \033[1msha256sum\033[0m," << ::std::endl
       << "                         and \033[1mshasum\033[0m. Note that the last component of \033[4mpath\033[0m must" << ::std::endl
       << "                         contain one of these names as a substring in order for" << ::std::endl
       << "                         \033[1mbpkg\033[0m to recognize which program is being used. You can" << ::std::endl
       << "                         also specify additional options that should be passed" << ::std::endl
       << "                         to the sha256 program with \033[1m--sha256-option\033[0m." << ::std::endl
       << ::std::endl
       << "                         If the sha256 program is not specified, then \033[1mbpkg\033[0m will" << ::std::endl
       << "                         try to discover if one of the above programs is" << ::std::endl
       << "                         available and use that. Currently, \033[1mbpkg\033[0m has the" << ::std::endl
       << "                         following preference order: \033[1msha256\033[0m, \033[1msha256sum\033[0m, and" << ::std::endl
       << "                         \033[1mshasum\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--sha256-option\033[0m \033[4mopt\033[0m      Additional option to be passed to the sha256 program." << ::std::endl
       << "                         See \033[1m--sha256\033[0m for more information on the sha256" << ::std::endl
       << "                         program. Repeat this option to specify multiple sha256" << ::std::endl
       << "                         options." << ::std::endl;

    os << std::endl
       << "\033[1m--tar\033[0m \033[4mpath\033[0m               The tar program to be used to extract package" << ::std::endl
       << "                         archives. For example, \033[1mgtar\033[0m or \033[1mbsdtar\033[0m. You can also" << ::std::endl
       << "                         specify additional options that should be passed to" << ::std::endl
       << "                         the tar program with \033[1m--tar-option\033[0m. If the tar program" << ::std::endl
       << "                         is not explicitly specified, then \033[1mbpkg\033[0m will use \033[1mtar\033[0m by" << ::std::endl
       << "                         default." << ::std::endl;

    os << std::endl
       << "\033[1m--tar-option\033[0m \033[4mopt\033[0m         Additional option to be passed to the tar program. See" << ::std::endl
       << "                         \033[1m--tar\033[0m for more information on the tar program. Repeat" << ::std::endl
       << "                         this option to specify multiple tar options." << ::std::endl;

    os << std::endl
       << "\033[1m--openssl\033[0m \033[4mpath\033[0m           The openssl program to be used for crypto operations." << ::std::endl
       << "                         You can also specify additional options that should be" << ::std::endl
       << "                         passed to the openssl program with \033[1m--openssl-option\033[0m." << ::std::endl
       << "                         If the openssl program is not explicitly specified," << ::std::endl
       << "                         then \033[1mbpkg\033[0m will use \033[1mopenssl\033[0m by default." << ::std::endl
       << ::std::endl
       << "                         The \033[1m--openssl*\033[0m values can be optionally qualified with" << ::std::endl
       << "                         the openssl command in the \033[4mcommand\033[0m\033[1m:\033[0m\033[4mvalue\033[0m\033[0m form. This" << ::std::endl
       << "                         makes the value only applicable to the specific" << ::std::endl
       << "                         command, for example:" << ::std::endl
       << ::std::endl
       << "                         bpkg rep-create                     \\" << ::std::endl
       << "                           --openssl rsautl:/path/to/openssl \\" << ::std::endl
       << "                           --openssl-option rsautl:-engine   \\" << ::std::endl
       << "                           --openssl-option rsautl:pkcs11    \\" << ::std::endl
       << "                           ..." << ::std::endl
       << ::std::endl
       << "                         An unqualified value that contains a colon can be" << ::std::endl
       << "                         specified as qualified with an empty command, for" << ::std::endl
       << "                         example, \033[1m--openssl :C:\\bin\\openssl\033[0m. To see openssl" << ::std::endl
       << "                         commands executed by \033[1mbpkg\033[0m, use the verbose mode (\033[1m-v\033[0m" << ::std::endl
       << "                         option)." << ::std::endl;

    os << std::endl
       << "\033[1m--openssl-option\033[0m \033[4mopt\033[0m     Additional option to be passed to the openssl program." << ::std::endl
       << "                         See \033[1m--openssl\033[0m for more information on the openssl" << ::std::endl
       << "                         program. The values can be optionally qualified with" << ::std::endl
       << "                         the openssl command, as discussed in \033[1m--openssl\033[0m. Repeat" << ::std::endl
       << "                         this option to specify multiple openssl options." << ::std::endl;

    os << std::endl
       << "\033[1m--auth\033[0m \033[4mtype\033[0m              Types of repositories to authenticate. Valid values" << ::std::endl
       << "                         for this option are \033[1mnone\033[0m, \033[1mremote\033[0m, \033[1mall\033[0m. By default only" << ::std::endl
       << "                         remote repositories are authenticated. You can request" << ::std::endl
       << "                         authentication of local repositories by passing \033[1mall\033[0m or" << ::std::endl
       << "                         disable authentication completely by passing \033[1mnone\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--trust\033[0m \033[4mfingerprint\033[0m      Trust repository certificate with a SHA256" << ::std::endl
       << "                         \033[4mfingerprint\033[0m. Such a certificate is trusted" << ::std::endl
       << "                         automatically, without prompting the user for a" << ::std::endl
       << "                         confirmation. Repeat this option to trust multiple" << ::std::endl
       << "                         certificates." << ::std::endl
       << ::std::endl
       << "                         Note that by default \033[1mopenssl\033[0m prints a SHA1 fingerprint" << ::std::endl
       << "                         and to obtain a SHA256 one you will need to pass the" << ::std::endl
       << "                         \033[1m-sha256\033[0m option, for example:" << ::std::endl
       << ::std::endl
       << "                         openssl x509 -sha256 -fingerprint -noout -in cert.pem" << ::std::endl;

    os << std::endl
       << "\033[1m--trust-yes\033[0m              Assume the answer to all authentication prompts is" << ::std::endl
       << "                         \033[1myes\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--trust-no\033[0m               Assume the answer to all authentication prompts is \033[1mno\033[0m." << ::std::endl;

    os << std::endl
       << "\033[1m--pager\033[0m \033[4mpath\033[0m             The pager program to be used to show long text." << ::std::endl
       << "                         Commonly used pager programs are \033[1mless\033[0m and \033[1mmore\033[0m. You" << ::std::endl
       << "                         can also specify additional options that should be" << ::std::endl
       << "                         passed to the pager program with \033[1m--pager-option\033[0m. If an" << ::std::endl
       << "                         empty string is specified as the pager program, then" << ::std::endl
       << "                         no pager will be used. If the pager program is not" << ::std::endl
       << "                         explicitly specified, then \033[1mbpkg\033[0m will try to use \033[1mless\033[0m." << ::std::endl
       << "                         If it is not available, then no pager will be used." << ::std::endl;

    os << std::endl
       << "\033[1m--pager-option\033[0m \033[4mopt\033[0m       Additional option to be passed to the pager program." << ::std::endl
       << "                         See \033[1m--pager\033[0m for more information on the pager program." << ::std::endl
       << "                         Repeat this option to specify multiple pager options." << ::std::endl;

    os << std::endl
       << "\033[1m--options-file\033[0m \033[4mfile\033[0m      Read additional options from \033[4mfile\033[0m. Each option should" << ::std::endl
       << "                         appear on a separate line optionally followed by space" << ::std::endl
       << "                         or equal sign (\033[1m=\033[0m) and an option value. Empty lines and" << ::std::endl
       << "                         lines starting with \033[1m#\033[0m are ignored. Option values can" << ::std::endl
       << "                         be enclosed in double (\033[1m\"\033[0m) or single (\033[1m'\033[0m) quotes to" << ::std::endl
       << "                         preserve leading and trailing whitespaces as well as" << ::std::endl
       << "                         to specify empty values. If the value itself contains" << ::std::endl
       << "                         trailing or leading quotes, enclose it with an extra" << ::std::endl
       << "                         pair of quotes, for example \033[1m'\"x\"'\033[0m. Non-leading and" << ::std::endl
       << "                         non-trailing quotes are interpreted as being part of" << ::std::endl
       << "                         the option value." << ::std::endl
       << ::std::endl
       << "                         The semantics of providing options in a file is" << ::std::endl
       << "                         equivalent to providing the same set of options in the" << ::std::endl
       << "                         same order on the command line at the point where the" << ::std::endl
       << "                         \033[1m--options-file\033[0m option is specified except that the" << ::std::endl
       << "                         shell escaping and quoting is not required. Repeat" << ::std::endl
       << "                         this option to specify more than one options file." << ::std::endl;

    os << std::endl
       << "\033[1m--default-options\033[0m \033[4mdir\033[0m    The directory to load additional default options files" << ::std::endl
       << "                         from." << ::std::endl;

    os << std::endl
       << "\033[1m--no-default-options\033[0m     Don't load default options files." << ::std::endl;

    p = ::bpkg::cli::usage_para::option;

    return p;
  }

  typedef
  std::map<std::string, void (*) (common_options&, ::bpkg::cli::scanner&)>
  _cli_common_options_map;

  static _cli_common_options_map _cli_common_options_map_;

  struct _cli_common_options_map_init
  {
    _cli_common_options_map_init ()
    {
      _cli_common_options_map_["-v"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::v_ >;
      _cli_common_options_map_["-V"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::V_ >;
      _cli_common_options_map_["--quiet"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::quiet_ >;
      _cli_common_options_map_["-q"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::quiet_ >;
      _cli_common_options_map_["--verbose"] =
      &::bpkg::cli::thunk< common_options, uint16_t, &common_options::verbose_,
        &common_options::verbose_specified_ >;
      _cli_common_options_map_["--jobs"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::jobs_,
        &common_options::jobs_specified_ >;
      _cli_common_options_map_["-j"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::jobs_,
        &common_options::jobs_specified_ >;
      _cli_common_options_map_["--no-result"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::no_result_ >;
      _cli_common_options_map_["--no-progress"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::no_progress_ >;
      _cli_common_options_map_["--build"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::build_,
        &common_options::build_specified_ >;
      _cli_common_options_map_["--build-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::build_option_,
        &common_options::build_option_specified_ >;
      _cli_common_options_map_["--fetch"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::fetch_,
        &common_options::fetch_specified_ >;
      _cli_common_options_map_["--fetch-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::fetch_option_,
        &common_options::fetch_option_specified_ >;
      _cli_common_options_map_["--fetch-timeout"] =
      &::bpkg::cli::thunk< common_options, size_t, &common_options::fetch_timeout_,
        &common_options::fetch_timeout_specified_ >;
      _cli_common_options_map_["--pkg-proxy"] =
      &::bpkg::cli::thunk< common_options, butl::url, &common_options::pkg_proxy_,
        &common_options::pkg_proxy_specified_ >;
      _cli_common_options_map_["--git"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::git_,
        &common_options::git_specified_ >;
      _cli_common_options_map_["--git-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::git_option_,
        &common_options::git_option_specified_ >;
      _cli_common_options_map_["--sha256"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::sha256_,
        &common_options::sha256_specified_ >;
      _cli_common_options_map_["--sha256-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::sha256_option_,
        &common_options::sha256_option_specified_ >;
      _cli_common_options_map_["--tar"] =
      &::bpkg::cli::thunk< common_options, path, &common_options::tar_,
        &common_options::tar_specified_ >;
      _cli_common_options_map_["--tar-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::tar_option_,
        &common_options::tar_option_specified_ >;
      _cli_common_options_map_["--openssl"] =
      &::bpkg::cli::thunk< common_options, qualified_option<openssl_commands, path>, &common_options::openssl_,
        &common_options::openssl_specified_ >;
      _cli_common_options_map_["--openssl-option"] =
      &::bpkg::cli::thunk< common_options, qualified_option<openssl_commands, strings>, &common_options::openssl_option_,
        &common_options::openssl_option_specified_ >;
      _cli_common_options_map_["--auth"] =
      &::bpkg::cli::thunk< common_options, bpkg::auth, &common_options::auth_,
        &common_options::auth_specified_ >;
      _cli_common_options_map_["--trust"] =
      &::bpkg::cli::thunk< common_options, std::set<string>, &common_options::trust_,
        &common_options::trust_specified_ >;
      _cli_common_options_map_["--trust-yes"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::trust_yes_ >;
      _cli_common_options_map_["--trust-no"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::trust_no_ >;
      _cli_common_options_map_["--pager"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::pager_,
        &common_options::pager_specified_ >;
      _cli_common_options_map_["--pager-option"] =
      &::bpkg::cli::thunk< common_options, strings, &common_options::pager_option_,
        &common_options::pager_option_specified_ >;
      _cli_common_options_map_["--options-file"] =
      &::bpkg::cli::thunk< common_options, string, &common_options::options_file_,
        &common_options::options_file_specified_ >;
      _cli_common_options_map_["--default-options"] =
      &::bpkg::cli::thunk< common_options, dir_path, &common_options::default_options_,
        &common_options::default_options_specified_ >;
      _cli_common_options_map_["--no-default-options"] =
      &::bpkg::cli::thunk< common_options, bool, &common_options::no_default_options_ >;
    }
  };

  static _cli_common_options_map_init _cli_common_options_map_init_;

  bool common_options::
  _parse (const char* o, ::bpkg::cli::scanner& s)
  {
    _cli_common_options_map::const_iterator i (_cli_common_options_map_.find (o));

    if (i != _cli_common_options_map_.end ())
    {
      (*(i->second)) (*this, s);
      return true;
    }

    return false;
  }
}

namespace bpkg
{
  ::bpkg::cli::usage_para
  print_bpkg_common_options_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mSYNOPSIS\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mbpkg\033[0m [\033[4mcommon-options\033[0m] ...\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mDESCRIPTION\033[0m" << ::std::endl
       << ::std::endl
       << "The common options control behavior that is common to all or most of the \033[1mbpkg\033[0m" << ::std::endl
       << "commands. They can be specified either before the command or after, together" << ::std::endl
       << "with the command-specific options." << ::std::endl;

    p = ::bpkg::common_options::print_usage (os, ::bpkg::cli::usage_para::text);

    return p;
  }

  ::bpkg::cli::usage_para
  print_bpkg_common_options_long_usage (::std::ostream& os, ::bpkg::cli::usage_para p)
  {
    CLI_POTENTIALLY_UNUSED (os);

    if (p != ::bpkg::cli::usage_para::none)
      os << ::std::endl;

    os << "\033[1mSYNOPSIS\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mbpkg\033[0m [\033[4mcommon-options\033[0m] ...\033[0m" << ::std::endl
       << ::std::endl
       << "\033[1mDESCRIPTION\033[0m" << ::std::endl
       << ::std::endl
       << "The common options control behavior that is common to all or most of the \033[1mbpkg\033[0m" << ::std::endl
       << "commands. They can be specified either before the command or after, together" << ::std::endl
       << "with the command-specific options." << ::std::endl;

    p = ::bpkg::common_options::print_long_usage (os, ::bpkg::cli::usage_para::text);

    return p;
  }
}

// Begin epilogue.
//
//
// End epilogue.

